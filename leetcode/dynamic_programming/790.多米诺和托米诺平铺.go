package leetcode

/*
 * @lc app=leetcode.cn id=790 lang=golang
 *
 * [790] 多米诺和托米诺平铺
 */

// @lc code=start
func numTilings(n int) int {
	mod := int(1e9 + 7)
	dp := make([][4]int, n+1)
	dp[0][0] = 0 //竖着  |
	dp[0][1] = 0 //左满了，右上横线 |—
	dp[0][2] = 0 //左满了，右下横线 |_
	dp[0][3] = 1 //两格都满了 ||  =  _| -|
	for i := 1; i <= n; i++ {
		dp[i][0] = dp[i-1][3]
		dp[i][1] = (dp[i-1][0] + dp[i-1][2]) % mod
		dp[i][2] = (dp[i-1][0] + dp[i-1][1]) % mod
		dp[i][3] = (dp[i-1][0] + dp[i-1][1] + dp[i-1][2] + dp[i-1][3]) % mod
	}
	return dp[n][3]
}

// @lc code=end

/*
	动态规划
	dp[i] 到当前第i格子时,有多少种排法
	dp[i][0] 表示当前末尾两个格子均为空
	dp[i][1] 表示当前末尾下面的格子为空
	dp[i][2] 表示当前末尾上面的格子为空
	dp[i][3] 表示当前末尾格子均被填满了

	然后开始填充，
	dp[i][0] 就只能填充一个竖着的 | ,即 等于 dp[i-1][3] ，因为只有1种填充方法
	dp[i][1] 因为下面格子为空，所以可以填一个 (dp[i-1][0]基础上的「 ） 和 (dp[i-1][2]基础上的 - )
	dp[i][2] 因为上面格子为空，所以可以填一个 (dp[i-1][0]基础上的 L ） 和 (dp[i-1][1]基础上的 _ )
	dp[i][3] 因为末尾两个格子均被填满了，所以可以填一个 (dp[i-1][0]基础上的 = ）
			和 (dp[i-1][1]基础上的 _| ) 和 (dp[i-1][2]基础上的 —| ) 和 (dp[i-1][3]基础上的 | )
*/
